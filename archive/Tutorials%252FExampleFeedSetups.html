<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Tribler</title>

<link rel="stylesheet" href="../css/style.css" />
<link rel="stylesheet" href="css/trac.css" type="text/css" />
<link rel="shortcut icon" href="img/favicon.ico" type="image/x-icon" />
<link rel="icon" href="img/favicon.ico" type="image/x-icon" />

<!--[if IE]>
<script>
  document.createElement('header');
  document.createElement('footer');
  document.createElement('section');
  document.createElement('nav');
</script>
<![endif]-->

<script type="text/javascript" src="js/jquery-1.10.2.min.js"></script>
<script type="text/javascript">
      var uservoiceOptions = {
        /* required */
        key: 'tribler',
        host: 'tribler.uservoice.com',
        forum: '90409',
        showTab: true,
        /* optional */
        alignment: 'right',
        background_color:'#f00',
        text_color: 'white',
        hover_color: '#009ec3',
        lang: 'en'
      };

      function _loadUserVoice() {
        var s = document.createElement('script');
        s.setAttribute('type', 'text/javascript');
        s.setAttribute('src', ("https:" == document.location.protocol ? "https://" : "http://") + "cdn.uservoice.com/javascripts/widgets/tab.js");
        document.getElementsByTagName('head')[0].appendChild(s);
      }
      _loadSuper = window.onload;
      window.onload = (typeof window.onload != 'function') ? _loadUserVoice : function() { _loadSuper(); _loadUserVoice(); };
    </script>

	<script type="text/javascript" src="../js/jquery-1.10.2.min.js"></script>
</head>

<body>

<div id="wrap">
	<header>
		<a href="index.html"><img src="../img/tribler-logo.png" alt="Return to the homepage" /></a>
		
		<nav>
			<ul>
				<li><a href="#">Tribler</a>
				    <ul>
				        <li><a href="#">About Tribler</a></li>
				        <li><a href="http://statistics.tribler.org">Statistics</a></li>
				    </ul>
				</li>
				<li><a href="download.html">Download</a></li>
				<li><a href="#">Users</a>
				    <ul>
				        <li><a href="howto.html">How does it work</a></li>
				        <li><a href="faq.html">FAQ</a></li>
				    </ul>
				</li>
				<li><a href="#">Developers</a>
				    <ul>
						<li><a href="https://github.com/Tribler/tribler">Github</a></li>
				        <li><a href="https://github.com/Tribler/tribler/wiki">Wiki</a></li>
				    </ul>
				</li>
				<li><a href="http://forum.tribler.org">Forum</a></li>
			</ul>
		</nav>
	</header>	
	
	<section id="trac"><table><tr><td><h1 id="ExampleLiveFeedSetups">Example Live Feed Setups</h1>
<p>
<div class="wiki-toc trac-nav"><ul><li>Developers Center
<ul><li><a class="wiki" href="TriblerGettingStarted.html">Getting Started</a>
<ul><li><a class="wiki" href="TriblerGettingStarted.html">Introduction</a>
</li><li><a class="wiki" href="TriblerSoftwareProcess.html">Development Process</a>
</li><li><a class="wiki" href="TriblerSoftwareProcess%25252FReleasing.html">Release Process</a>
</li><li><a class="wiki" href="tipsTricks.html">Tips &amp; Tricks</a>
</li></ul></li><li><a class="wiki" href="TriblerArchitecture.html">Architecture</a>
<ul><li><a class="wiki" href="TriblerArchitecture.html">Overview</a>
</li><li><a class="wiki" href="DotTriblerFiles.html">Local Storage Structure</a>
</li></ul></li><li><a class="ext-link" href="http://www.tribler.org/api/"><span class="icon">​</span>API</a>
<ul><li><a class="ext-link" href="http://www.tribler.org/api/"><span class="icon">​</span>Tribler Core</a>
</li><li><a class="wiki" href="TriblerAPIRationale.html">Rationale</a>
</li></ul></li><li><a class="wiki" href="Tutorials.html">Tutorials</a>
<ul><li><a class="wiki" href="Tutorials.html">Overview</a>
</li><li><a class="wiki" href="Tutorials%25252FHelloWorld.html">1. Download Hello world</a>
</li><li><a class="wiki" href="Tutorials%25252FVideoOnDemand.html">2. Video on Demand</a>
</li><li><a class="wiki" href="Tutorials%25252FLiveStreaming.html">3. Live Streaming</a>
</li><li><a class="wiki" href="Tutorials%25252FSeedingTorrents.html">4. Content injection</a>
</li><li><a class="wiki" href="Tutorials%25252FExampleFeedSetups.html">Example live feed setups</a>
</li></ul></li><li><a class="ext-link" href="http://svn.tribler.org/bt2-design/proto-spec-unified/trunk/proto-spec-current.pdf"><span class="icon">​</span>Protocol specification</a>
</li><li><a class="ext-link" href="http://svn.tribler.org/abc/branches/mainbranch"><span class="icon">​</span>Tools</a>
<ul><li><a class="ext-link" href="http://svn.tribler.org/abc/branches/mainbranch"><span class="icon">​</span>Source browser</a>
</li><li>[milestone: Roadmap] 
</li><li><a href="/timeline">Timeline</a>
</li><li><a class="ext-link" href="http://forum.tribler.org"><span class="icon">​</span>Forum</a>
</li></ul></li></ul></li></ul><p>
   
</p>
</div></td><td>
</p>
<p>
On this page we will describe a couple of concrete setups from broadcasting live from different video sources<br />
such as a DV camera, DVB-T receiver or simple webcam. 
</p>
<h2 id="ViaWindows">Via Windows</h2>
<p>
In general, the simplest way of getting a feed up is via Windows and the <a class="ext-link" href="http://www.videolan.org/vlc/"><span class="icon">​</span>VideoLanClient (VLC)</a>.<br />
VLC can stream both <a class="missing" href="#">DirectShow</a> capable devices such as Webcams or DV cameras, as well as<br />
DVB-T cards that support the <a class="ext-link" href="http://www.microsoft.com/whdc/archive/broadcast.mspx"><span class="icon">​</span>Windows Broadcast Driver Architecture (BDA)</a>.<br />
E.g. the <a class="ext-link" href="http://www.hauppauge.de/nl/site/products/data_hvr900.htmlthe"><span class="icon">​</span>Hauppauge WinTV-HVR 900H</a>. For BDA support you need VLC 0.9.2 or above.
</p>
<p>
We'll explain how to setup VLC such that it offers a ready-to-broadcast stream for both classes:
</p>
<ol><li>Attach any <a class="missing" href="#">DirectShow</a> capable device to the machine. 
</li><li>Install and run VLC. 
</li><li>Select "Open Capture Device" from the File menu (called Media in vlc 0.9)
</li></ol><h3 id="DirectShow"><a class="missing" href="#">DirectShow</a></h3>
<ol start="4"><li>Select the video device from the "Video device name" dropdown box (may need to press "Refresh list" first)
</li><li>Check the "<a class="missing" href="#">Stream/Save</a>" box at the bottom. (or use the dropdown box next to the play button (vlc 0.9)).
</li><li>Click the "Settings..." button at the bottom.
</li><li>Check "Play locally" and "HTTP"
</li><li>Select encapsulation method "MPEGTS"
</li><li>Check and select the video and audio encoding you want (We used mp4v at 512 kbps, scale .5, no audio successfully)
</li><li>Click OK twice
</li></ol><h3 id="BDADVB-T">BDA / DVB-T</h3>
<ol start="4"><li>Change the "Video capture mode" from <a class="missing" href="#">DirectShow</a> to "DVB <a class="missing" href="#">DirectShow</a>"
</li><li>Select the DVB-type: DVB-T
</li><li>Set the Transponder/multiplex frequency. For the Netherlands, use the "Zenderlokatie" table <a class="ext-link" href="http://www.radio-tv-nederland.nl/dvbt/digitenne-kpntv.html"><span class="icon">​</span>on this page</a>. The frequency must be entered in kHZ, so e.g. 618000 for Amsterdam (RAI).
</li><li>Use the dropdown box next to the play button to select "Stream"
</li><li>Check "Play locally" and "HTTP"
</li><li>Select encapsulation method "MPEGTS"
</li><li>Check and select the video and audio encoding you want.
</li><li>Click Stream
</li></ol><p>
It's unclear how to select another channel. When in GUI mode you can change it via <br />
"<a class="missing" href="#">Playback/Programs</a>". You may also need to run VLC from the commandline with the composed <br />
command-string, rather than use the GUI. TODO: investigate the "--programs=" option.
</p>
<h3 id="Broadcasting">Broadcasting</h3>
<p>
After these steps VLC now offers the video transcoded according to your settings on <br />
<a class="ext-link" href="http://yourhostname:1234/"><span class="icon">​</span>http://yourhostname:1234/</a> This HTTP source can be used directly by the Tribler tools to <br />
broadcast, as follows. You can do this on Windows, Mac or Linux, broadcasting the video <br />
once VLC offers it is platform independent.
</p>
<ol><li>Get the source:
<pre class="wiki">svn co http://svn.tribler.org/abc/branches/player-release-1.0
</pre></li><li>Install the required additional libraries as described in <a class="ext-link" href="http://svn.tribler.org/abc/branches/player-release-1.0/Tribler/readme.txt"><span class="icon">​</span>Tribler/readme.txt</a>
</li><li>Set the PYTHONPATH shell variable to the current dir
<pre class="wiki">set PYTHONPATH=.  (windows)
export PYTHONPATH=. (Linux)
</pre></li><li>Start the Tribler broadcast:
<pre class="wiki">python Tribler/Tools/createlivestream.py --name streamname.mpegts --source http://yourhostname:1234/ --destdir . 
</pre></li><li>If you have a bitrate other than the default (512 kbps) use the <tt>--bitrate xyz</tt> <br />
</li></ol><p>
option where xyz is the bitrate in bytes per second. For high bitrates you may also want<br />
to change the size at which we transmit data using the <tt>--piecesize xyz</tt> option.<br />
More info below<br />
</p>
<ol start="6"><li>The createlivestream.py program will now write a <tt>streamname.mpegts.tstream</tt> file <br />
</li></ol><p>
that you should distribute to your users. They should start their swarmplayers using this<br />
torrent-like file.
</p>
<p>
We use this setup to broadcast from a DV camera.
</p>
<p>
Note that the .tstream doesn't depend on the content. So you can reuse the same .tstream <br />
file for broadcasting different streams at different times, as long as its parameters<br />
(bitrate, piecesize, name) do not change. A special case are authenticated streams (the <br />
default). Here the .tstream will remain the same when the public/private keypair remains <br />
the same (in addition to the params). In practice, keeping the public/private keypair the <br />
same means you should not delete the <tt>streamname.sauth</tt> file that the script writes <br />
the first time. You can disable our default source-authentication scheme to reduce the CPU<br />
usage during playback. For that use the <tt>Tribler/Tools/createlivestream-noauth.py</tt><br />
script.
</p>
<h2 id="DVB-TonLinux">DVB-T on Linux</h2>
<p>
Our first setup is a DVB-T receiver attached to a Linux box. The DVB-T is a Hauppauge <br />
WinTV Nova-T USB stick that is supported by Linux. We assume you have setup the stick <br />
correctly and can watch TV from it (e.g. <tt>cat /dev/dvb/adapter0/dvr0 | vlc -</tt>). You <br />
can now broadcast the TV signal as follows. We assume the channel information needed by<br />
the stick is in a file called <tt>channels.conf</tt>
</p>
<ol><li>Tune in to the desired channel (we do this in the background)
<pre class="wiki">(tzap -c channels.conf -r "SomeChannel" &gt; /dev/null 2&gt;&amp;1 &amp;)
</pre></li><li>Start the createlivestream.py
<pre class="wiki">python Tribler/Tools/createlivestream.py --name streamname.mpegts --source pipe:generate-video.sh --duration 1:00:00 --port 7765 --destdir . &gt; /tmp/dvb-t-live.log 2&gt;&amp;1
</pre></li><li>This command requires a <tt>generate-video.sh</tt> script in the current directory that looks like:
<pre class="wiki">ffmpeg -f mpegts -vsync 1 -map 0.0:0.1 -map 0.1 -i /dev/dvb/adapter0/dvr0 -vcodec mpeg4 -vb 428288 -s 320x240 -acodec libmp3lame -ab 96000 -ac 1 -f mpegts -
</pre></li><li>In other words, FFMPEG takes the raw MPEG transport stream from the DVB-T receiver<br />
</li></ol><p>
and transcodes it to 512 kbps of MPEG4 video and MP3 audio, synchronized on audio, and<br />
outputs this on stdout, so createlivestream.py can read it. 
</p>
<ol start="5"><li>We have experimented with H.264 via the libx264 library, but somehow the combination<br />
</li></ol><p>
of libx264 and current ffmpeg encoding in a pipeline gives motion prediction errors. <br />
Try for yourself:
</p>
<pre class="wiki">ffmpeg -f mpegts -vsync 1 -map 0.0:0.1 -map 0.1 -i /dev/dvb/adapter0/dvr0 -vcodec libx264 -vb 428288 -g 16 -s 320x240 -acodec libfaac -ab 96000 -ac 1 -deinterlace -f mpegts -
</pre><p>
We set GOP (-g) to 16 to speedup tuning in at playback. With the default ffmpeg setting this  takes a long time.
</p>
<ol start="6"><li>We did manage to get H.264 working with mencoder:
<pre class="wiki">mencoder -cache 8192 -ovc x264 -x264encopts bitrate=1024 -nosound  -of lavf -lavfopts i_certify_that_my_video_stream_does_not_use_b_frames:format=mpegts -vf scale=640:360 -quiet -o /dev/stdout /dev/dvb/adapter0/dvr0
</pre></li></ol><h2 id="VLConLinux">VLC on Linux</h2>
<p>
For some Linux sources (e.g. IP multicast) you can use VLC to do the transcoding. <br />
Unfortunately, there appears to be something wrong when we try to read directly from a <br />
DVB-T device and try to offer it via HTTP. VLC starts as it should, but its HTTP server<br />
produces no data with the MPEGTS demux enabled. Here's an example for 1 mbps H.264 from a<br />
IP multicast source:
</p>
<pre class="wiki">vlc --daemon udp://@224.0.0.1:2001 --sout='#transcode{vcodec=h264,venc=x264{vbv-maxrate=512,vbv-minrate=512,qcomp=0,ratetol=0,keyint=20}vb=512,width=640,height=360,acodec=none,scodec=none,me=umh}:duplicate{dst=std{access=http,mux=ts,dst=:8081}}' :sout-all
</pre><h2 id="DVCameraonLinux">DV Camera on Linux</h2>
<p>
For <a class="ext-link" href="http://trial.p2p-next.org/"><span class="icon">​</span>our first public trial</a> we used a DV camera connected to a remote Linux box directly. <br />
The remote box would grab the IEEE1394, transcode it to the right format and transmit it<br /> to the broadcast box via SSH. This setup is described <a class="wiki" href="StreamingExperiment.html">on another page</a>.
</p>
<h2 id="LoopingaFile">Looping a File</h2>
<p>
Newer versions of Tribler support the "--fileloop True" option for createlivestream.py that allows you to loop a file as if it were a live broadcast.
</p>
<h2 id="OggLiveStreaming">Ogg Live Streaming</h2>
<p>
For the new <a class="wiki" href="SwarmPlayer.html">SwarmPlayer</a> you need a feed in Ogg format with theora+vorbis codecs. Also the feed needs to replay the Ogg headers each time you tune in, as players cannot just tune-in midstream as with MPEG-TS. The software that offers this functionality is the <a class="ext-link" href="http://icecast.org/"><span class="icon">​</span>IceCast server</a>. It acts as a relay server, so you need to inject a feed into it that will be read by createlivestream.py for P2P rebroadcast. There are several clients that can inject, we have tested with VLC. 
So there are three steps to creating a P2P Ogg live stream:
</p>
<ol><li>Start default <a class="missing" href="#">IceCast</a> server (just change passwords in icecast.xml, tested 2.3.2):
<pre class="wiki">cd  "\Program Files\Icecast2 Win32"
icecast2console.exe -c icecast.xml
</pre></li></ol><ol start="2"><li>Inject e.g. camera: feed transcoded to Ogg/theora+vorbis using VLC:
<pre class="wiki">vlc dshow:// --sout "#transcode{vcodec=theo,vb=800,scale=1,acodec=vorb,ab=128,channels=2,samplerate=44100}:duplicate{dst=std{access=shout,mux=ogg,dst=source:hackme@127.0.0.1:8000/cam3.ogg},dst=display}" --no-sout-rtp-sap --no-sout-standard-sap --sout-keep
</pre></li></ol><ol start="3"><li>Rebroadcast using P2P:
<pre class="wiki">python Tribler\Tools\createlivestream.py --name MacCam3.ogg --source http://127.0.0.1:8000/cam3.ogg --bitrate 132000
</pre></li></ol><p>
Unfortunately, this software combo is not very stable. The Ogg that VLC 1.1.2 generates cannot be replayed by Firefox 3.6.8. Older VLCs (e.g., 0.9.8) did generate playable Ogg, but they could not reliable grab a built-in camera.
</p>
<h2 id="P2PParameters">P2P Parameters</h2>
<p>
There are several parameters you can play with to optimize performance:
</p>
<ul><li>Piecesize
</li><li>Subpiecesize aka chunksize
</li><li>"Duration"
</li><li>Live-source Authentication method
</li><li>Disk space allocation policy
</li><li>Source parameters: number of upload slots, auxiliary seeders and bandwidth limits
</li></ul><p>
The piecesize determines the highest level of blocks in which the stream is divided. <a class="ext-link" href="http://pds.twi.tudelft.nl/reports/2009/PDS-2009-002.pdf"><span class="icon">​</span>Simulations have shown (Fig. 5)</a> that a piecesize of 32K is preferred for live. Above 64K it can have a negative impact on the swarm, with peers not being able to watch the video. But using the larger 64K value will result in less pieces/second to process and thus lower resource usage.
</p>
<p>
Another parameter is the chunksize. A piece is requested from a peer in a number of chunks, currently 16K. If we increase the chunksize, there is less REQUEST+PIECE packets per second. Normally this parameter is fixed for <a class="wiki" href="BitTorrent.html">BitTorrent</a>, but you can play around with it, the wire protocol can handle that. See <a class="missing" href="#">DownloadConfig</a>.set_download_slice_size(). A microtest showed little impact.
</p>
<p>
"duration" is the amount of time a live stream plays before it starts reusing piece numbers. As such, it together with the piece size determines the range of piece numbers, following the simple formula:
</p>
<blockquote>
<p>
npieces = (avg. bitrate * duration) / piecesize
</p>
</blockquote>
<p>
The range of piece numbers is an important performance factor. A large range costs CPU as some code needs to for-loop over the entire range. So a good performance optimization we've used is to increase piece size and to set duration from 1 hour to 0.5 hours. Making duration too small may cause problems, as peers that drift a little in playback time may simultaneously use the same piece numbers but from different epochs.
</p>
<p>
Another parameter is the live-source authentication method to use. We support 3 methods:
</p>
<ul><li>No auth
</li><li>ECDSA auth with arbitrary key-length
</li><li>RSA auth with arbitrary key-length
</li></ul><p>
Using no authentication is very unwise because it will make the swarm susceptible to malfunctioning and malicious clients. Malfunctioning clients that get stuck will advocate pieces with old content (different epoch, i.e. previous loop over the piece range). Malicious clients can replace the content of pieces. The performance of the public-key based methods highly depends on cryptosystem and key length. Investigations show that RSA with small key lengths (e.g. 768 bits) performs the best in terms of CPU requirements for verifying the signature. If that is still to expensive, please turn off only the signature verification at the client such that the protection against malfunctioning clients remains in place.
</p>
<p>
Final parameter is disk-allocation policy. We haven't tested the effect of this parameter yet, but using
the DISKALLOC_SPARSE policy on UNIX systems could theoretically increase performance. A client hooks into a live stream at a certain piece number and then starts downloading pieces in its proximity. If this piece number is high it could be beneficial to create a hole at the beginning using sparse support. Update: the SPARSE policy is the default on *NIX.
</p>
<p>
The source, that is, the createlivestream.py script can also be tuned. Source parameters are the  number of upload slots, auxiliary seeders and bandwidth limits. We used 32 upload slots for our large live streaming trial. In addition, we had 5 auxiliary seeders (<a class="missing" href="#">DownloadStartupConfig</a>.set_live_aux_seeders()), that is, peers that get preference at the source, meaning they are always unchoked and which thus help to distribute the signal faster.
</p>
    <script type="text/javascript">
        (function($){
          $.loadStyleSheet = function(href, type) {
            type = type || "text/css";
            $(document).ready(function() {
              if (document.createStyleSheet) { // MSIE
                document.createStyleSheet(href);
              } else {
                $("<link rel='stylesheet' type='" + type + "' href='" + href + "' />")
                  .appendTo("head");
              }
            });
          }
         
        })(jQuery);
        jQuery.loadStyleSheet("css/tracnav.css", "text/css");
    </script></td>
</tr>
</table>
</section>	

</body>
</html>