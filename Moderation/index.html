<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Tribler</title>

<link rel="stylesheet" href="/css/style.css" />
<link rel="stylesheet" href="/css/animate.min.css">
<link rel="stylesheet" href="/css/trac.css" type="text/css" />
<link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon" />
<link rel="icon" href="/img/favicon.ico" type="image/x-icon" />

<!--[if lt IE 9]>
<script src="/js/html5shiv.js"></script>
<![endif]-->



<script src="/js/wow.min.js"></script>
<script>
 new WOW().init();
</script>

<script type="text/javascript" src="/js/jquery-1.10.2.min.js"></script>
<script type="text/javascript">
      var uservoiceOptions = {
        /* required */
        key: 'tribler',
        host: 'tribler.uservoice.com',
        forum: '90409',
        showTab: true,
        /* optional */
        alignment: 'right',
        background_color:'#f00',
        text_color: 'white',
        hover_color: '#009ec3',
        lang: 'en'
      };

      function _loadUserVoice() {
        var s = document.createElement('script');
        s.setAttribute('type', 'text/javascript');
        s.setAttribute('src', ("https:" == document.location.protocol ? "https://" : "http://") + "cdn.uservoice.com/javascripts/widgets/tab.js");
        document.getElementsByTagName('head')[0].appendChild(s);
      }
      _loadSuper = window.onload;
      window.onload = (typeof window.onload != 'function') ? _loadUserVoice : function() { _loadSuper(); _loadUserVoice(); };
    </script>

</head>

<body>
	<header>
		<div class="wow fadeInDown">
			<div class="wow fadeInLeft">
				<a href="https://www.facebook.com/TriblerTeam"><img class="facebook-icon" src="/img/facebook-icon.png" /></a>
				<a href="https://twitter.com/TriblerTeam"><img class="twitter-icon" src="/img/twitter-icon.png" /></a>
				<a href="https://github.com/Tribler"><img class="github-icon" src="/img/github-icon.png" /></a>
			</div>
			<a href="/"><img class="header-logo" src="/img/tribler-logo.png" alt="Return to the homepage" /></a>
				
			<nav>
			<ul>
				<li><a href="/">Tribler</a>
				    <ul>
				        <li><a href="/about.html">About Tribler</a></li>
				        <li><a href="/anonymity.html">Towards Anonymity</a></li>
				        <li><a href="http://statistics.tribler.org">Statistics</a></li>
				    </ul>
				</li>
				<li><a href="/download.html">Download</a></li>
				<li><a href="/support-index.html">Support</a>
				    <ul>
				        <li><a href="/howto.html">Get Started</a></li>
				        <li><a href="/faq.html">FAQ</a></li>
				    </ul>
				</li>
				<li><a href="/developer-index.html">Developers</a>
				    <ul>
					<li><a href="https://github.com/Tribler/tribler">Github</a></li>
					<li><a href="https://github.com/Tribler/tribler/wiki">Wiki</a></li>
					<li><a href="/TitleIndex">Archive</a></li>
				    </ul>
				</li>
				<li><a href="http://forum.tribler.org">Forum</a></li>
			</ul>
		</nav>
	</header>	
	
	<section id="trac"><table><tr><td><h1 id="Moderationandrichmetadata">Moderation and rich metadata</h1>
<p>
<em>Status: operational code, waiting for deployment and improvements</em>
</p>
<p>
Currently every peer can publish .torrent files using <a class="wiki" href="/Buddycast3">Buddycast3</a>. No moderation mechanism exists yet. An unsolved problem is how to create a metadata infrastructure for Video on Demand that facilitates user-generated metadata. Research question : <em>Design, implementation, and evaluation of an efficient epidemic protocol for distribution of rich-metadata with pollution prevention measures</em>
</p>
<p>
We have worked out a roadmap for addressing the above research question in incremental stages until June 2009. Each stage represents an improvement in both moderation sophistication and growth of the moderator community. Key is that the software and community use of the new features are in balance. Measurements on related projects such as the <a class="ext-link" href="http://musicbrainz.org/generated/plot_count.moderator.png"><span class="icon">​</span>MusicBrainz numbers</a> or <a class="ext-link" href="http://www.cs.dartmouth.edu/reports/abstracts/TR2007-606/"><span class="icon">​</span>Wikipedia traces</a> show that it takes many months or even years to grow a community of moderators. Also, the robustness to vandalism or fraud will also grow over time as we see normal usage patterns and can detect anomalies better. Furthermore, the software will give the growing moderator community increasingly more power over the metadata, until they are in full control. 
</p>
<h2 id="a5-stageroadmap">5-stage roadmap</h2>
<p>
<strong>Research questions for each stage</strong>:
</p>
<ul><li>How can we enable peers to automatically approve all swarms originating from a trusted RSS feed? <br />Requirement: <em>none</em>
</li><li>How can we enable peers to freely approve any swarm? How can we facilitate the identification of <em>identical swarms</em> and present the user only with the most healthy swarm in keyword search results? <br />Requirement: 20+ active moderators and 100+ active voters; all of which are online 20% of the time.
</li><li>How can we give moderators the ability to correct core swarm metadata, such as swarm name, spoken language, and video quality? <br />Requirement: a group of 50+ active moderators and 250+ active voters; all of which are online 20% of the time.
</li><li>How can we facilitate users adding subtitles to swarms? <br />Requirement: 50+ active subtitle moderators. Victor expands PEX with discovery of extra metadata.
</li><li>How can we disable the showing of non-approved swarms in keyword searches? How can we facilitate giving every user the ability to add tags &amp; a rating to every swarm? <br />Requirement: Some sort of <em>turbo swarm discovery mechanism</em> for moderators which allows them to see and give approval to new swarms in minutes. A community of moderators from which at any given point in time there are at least 10+ of them searching &amp; approving swarms. A group of 250+ active tagging&amp;rating users; all of which are online 20% of the time. 
</li></ul><p>
General research challenges: scalability, robustness to fraud, acceptable propagation speed, low bandwidth usage on moderator. <a class="ext-link" href="http://www.tribler.org/browser/abc/branches/vincent/d07-09-18-modcast-from-mainbranch-r5355"><span class="icon">​</span>Our proof-of-principle Python code</a>. Related <a class="ext-link" href="http://www.cs.vu.nl/~ndrost/hpdc127-drost.pdf"><span class="icon">​</span>Gossip work</a>
</p>
<h2 id="Draftoutlineofarchitecture">Draft outline of architecture</h2>
<p>
We have chosen to design and implement the simple moderation protocol using gossiping (based on <a class="wiki" href="/BuddyCast">BuddyCast</a>). Peers can create and receive moderations, which contain <em>extra</em> data for a given torrent:
</p>
<ul><li>spoken language
</li><li>subtitles
</li><li>description
</li><li>thumbnail
</li><li>tags
</li></ul><p>
We have chosen not to enable peers to change the title of a torrent. This would make finding a torrent with a badly moderated title very difficult. Furthermore we have decided not to include majority voting as a tie-breaker between moderations, but to use the last moderation. This is far more scalable when there is no trust mechanism. (Determining the majority in a non-secure environment requires either trust or every peer gathering all the moderations itself.) As a pollution prevention measure we use blacklisting. Users can block moderators that send bad moderations. This is done for the PermID and also for the IP-address of the peer. To further prevent the propagation of bad moderations we do not automatically forward moderations. Peers have to indicate that they are willing to forward moderations for certain moderators.
Moderations are signed using the Elliptic Curve Digital Signature Algorithm which is also used to verify the <a class="wiki" href="/PermID">PermIDs</a>. This enables the peers to verify the authenticity of the message even if it is forwarded by a third party. The protocol allows for rate-control to minimize bandwidth consumption.
</p>
<p>
The above design is implemented as a proof-of-principle. Several simulations have been conducted to determine scalability and robustness to fraud. Please read the following documents for more details: --- by Vincent, --- ModerationCAST design document of 7 pages with the message format, a
nd finally the very extensive --- Msc thesis on P2P moderation]
</p>
<h2 id="InitialImplementationDesign">Initial Implementation Design</h2>
<p>
(Dave and Rameez currently working on this)
</p>
<p>
For an initial implementation we decided to simplify, where possible, Vincents design and also make a few additions. Mainly, we have excluded a lot of the meta-data fields only keeping essentials. <a class="wiki" href="/ModerationCast">ModerationCast</a> is a pre-requise for <a class="missing" href="#">VoteCast</a>, which will allow users to rate (vote for) moderators.
</p>
<p>
<a class="wiki" href="/ModerationCast">ModerationCast</a> produces three kinds of message:
</p>
<ul><li>Moderation_Have messages which signal to other nodes a set of available moderators stored in the megacache that can be sent if required.
</li><li>Moderation_Request messages which are a reply to a moderation_have message listing which moderations are required
</li><li>Moderation_Reply messages which contain the actual metadata for the requested moderations as previously listed in the moderation_request message.
</li></ul><p>
Moderation_Have message:
</p>
<ul><li>Hash (23 bytes)
</li><li>Time_Stamp (4 bytes)
</li></ul><p>
repeated up to 100 records
</p>
<p>
After <a class="wiki" href="/BuddyCast">BuddyCast</a> returns a peer from the overlay (approx. every 15 seconds) a Moderation_Have message is passed to it (push) containing a list of hashes and time_stamps of moderations, stored locally. The hash represents a .torrent and the time_stamp indicates the creation time of the stored moderation. Up to 100 such Hash, Time_stamp pairs may be sent in one message. The local node selects moderations to include in the list based on a 50:50 policy. 50% of moderations are selected randomly and 50% of moderations are selected based on time_stamp recency.
</p>
<p>
Moderation_Request message:
</p>
<ul><li>Hash (23 Bytes)
</li></ul><p>
repeated up to 100 entries
</p>
<p>
Any node that receives a Moderation_Have message examines it to determine if it wishes to request any of the available moderations. A node will ask for any new (previously unseen) moderation or any more up-to-date moderation (based on time_stamp). More up-to-date moderations overwrite old moderations. The node sends back a Moderation_Request message containing a list of the Hashes of the required moderations.
</p>
<p>
Moderation_Reply message:
</p>
<ul><li>Hash bitstring (23 bytes)
</li><li>Time_Stamp bitstring (4 bytes)
</li><li>Moderator_ID bitstring (124 bytes)
</li><li>Moderator_name string (30 bytes) [eg: &#34;Dave2000&#34; Or &#34;DemocracyNow&#34;]
</li><li>Signature (67 bytes)
</li></ul><p>
Repeated up to 100 records
</p>
<p>
The Moderation_Reply message contains the actual moderation metadata requested by the remote peer. The local peer extracts the request moderations from its localDB and sends it.
</p>
<p>
Moderation table:
</p>
<p>
stored in local megacache for each moderator encountered is mod-perm-ID, vote (0,+ or -)
</p>
<div id="attachments">
<h3 class="foldable">Attachments</h3>
<ul>
<li><a href="http://kayapo.tribler.org/trac/raw-attachment/wiki/Moderation/idee%5B50-5_4FullDetails%5D.png">idee[50-5_4FullDetails].png</a>
(<span>500.5KB</span>)</li><li><a href="http://kayapo.tribler.org/trac/raw-attachment/wiki/Moderation/idee%5B50-6%5D%5Bedit_mode%5D%5B2%5D.png">idee[50-6][edit_mode][2].png</a>
(<span>487.6KB</span>)</li><li><a href="http://kayapo.tribler.org/trac/raw-attachment/wiki/Moderation/idee%5B50-6%5D%5Bedit_mode%5D.png">idee[50-6][edit_mode].png</a>
(<span>486.0KB</span>)</li><li><a href="http://kayapo.tribler.org/trac/raw-attachment/wiki/Moderation/ModerationCAST.jpg">ModerationCAST.jpg</a>
(<span>161.6KB</span>)</li><li><a href="http://kayapo.tribler.org/trac/raw-attachment/wiki/Moderation/ModerationCASTDesign.pdf">ModerationCASTDesign.pdf</a>
(<span>164.9KB</span>)</li><li><a href="http://kayapo.tribler.org/trac/raw-attachment/wiki/Moderation/Thesis%20-%20draft.pdf">Thesis - draft.pdf</a>
(<span>1.7MB</span>)</li><li><a href="http://kayapo.tribler.org/trac/raw-attachment/wiki/Moderation/Vincent%20Heinink%20-%20MSc%20Thesis%20Computer%20Science%20-%20Final%20Version.pdf">Vincent Heinink - MSc Thesis Computer Science - Final Version.pdf</a>
(<span>1.7MB</span>)</li><li><a href="http://kayapo.tribler.org/trac/raw-attachment/wiki/Moderation/vincent_msc_moderationcast_v1.pdf">vincent_msc_moderationcast_v1.pdf</a>
(<span>942.5KB</span>)</li><li><a href="http://kayapo.tribler.org/trac/raw-attachment/wiki/Moderation/vincent_onderzoekstaak_P2P_VoD_FINAL.pdf">vincent_onderzoekstaak_P2P_VoD_FINAL.pdf</a>
(<span>1.5MB</span>)</li></ul>
</div></td>
</tr>
</table>
</section>	

</body>
</html>